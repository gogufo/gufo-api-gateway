// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: microservice.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_microservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_microservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_microservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_microservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_microservice_2eproto;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Error_MetaEntry_DoNotUse;
struct Error_MetaEntry_DoNotUseDefaultTypeInternal;
extern Error_MetaEntry_DoNotUseDefaultTypeInternal _Error_MetaEntry_DoNotUse_default_instance_;
class FileChunk;
struct FileChunkDefaultTypeInternal;
extern FileChunkDefaultTypeInternal _FileChunk_default_instance_;
class InternalRequest;
struct InternalRequestDefaultTypeInternal;
extern InternalRequestDefaultTypeInternal _InternalRequest_default_instance_;
class InternalRequest_ArgsEntry_DoNotUse;
struct InternalRequest_ArgsEntry_DoNotUseDefaultTypeInternal;
extern InternalRequest_ArgsEntry_DoNotUseDefaultTypeInternal _InternalRequest_ArgsEntry_DoNotUse_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Request_ArgsEntry_DoNotUse;
struct Request_ArgsEntry_DoNotUseDefaultTypeInternal;
extern Request_ArgsEntry_DoNotUseDefaultTypeInternal _Request_ArgsEntry_DoNotUse_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class Response_DataEntry_DoNotUse;
struct Response_DataEntry_DoNotUseDefaultTypeInternal;
extern Response_DataEntry_DoNotUseDefaultTypeInternal _Response_DataEntry_DoNotUse_default_instance_;
class StringMap;
struct StringMapDefaultTypeInternal;
extern StringMapDefaultTypeInternal _StringMap_default_instance_;
class StringMap_EntriesEntry_DoNotUse;
struct StringMap_EntriesEntry_DoNotUseDefaultTypeInternal;
extern StringMap_EntriesEntry_DoNotUseDefaultTypeInternal _StringMap_EntriesEntry_DoNotUse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Error* Arena::CreateMaybeMessage<::Error>(Arena*);
template<> ::Error_MetaEntry_DoNotUse* Arena::CreateMaybeMessage<::Error_MetaEntry_DoNotUse>(Arena*);
template<> ::FileChunk* Arena::CreateMaybeMessage<::FileChunk>(Arena*);
template<> ::InternalRequest* Arena::CreateMaybeMessage<::InternalRequest>(Arena*);
template<> ::InternalRequest_ArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::InternalRequest_ArgsEntry_DoNotUse>(Arena*);
template<> ::Request* Arena::CreateMaybeMessage<::Request>(Arena*);
template<> ::Request_ArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::Request_ArgsEntry_DoNotUse>(Arena*);
template<> ::Response* Arena::CreateMaybeMessage<::Response>(Arena*);
template<> ::Response_DataEntry_DoNotUse* Arena::CreateMaybeMessage<::Response_DataEntry_DoNotUse>(Arena*);
template<> ::StringMap* Arena::CreateMaybeMessage<::StringMap>(Arena*);
template<> ::StringMap_EntriesEntry_DoNotUse* Arena::CreateMaybeMessage<::StringMap_EntriesEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum UploadStatusCode : int {
  Unknown = 0,
  Ok = 1,
  Failed = 2,
  UploadStatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UploadStatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UploadStatusCode_IsValid(int value);
constexpr UploadStatusCode UploadStatusCode_MIN = Unknown;
constexpr UploadStatusCode UploadStatusCode_MAX = Failed;
constexpr int UploadStatusCode_ARRAYSIZE = UploadStatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UploadStatusCode_descriptor();
template<typename T>
inline const std::string& UploadStatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UploadStatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UploadStatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UploadStatusCode_descriptor(), enum_t_value);
}
inline bool UploadStatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UploadStatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UploadStatusCode>(
    UploadStatusCode_descriptor(), name, value);
}
// ===================================================================

class Request_ArgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Request_ArgsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Request_ArgsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Request_ArgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Request_ArgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Request_ArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Request_ArgsEntry_DoNotUse& other);
  static const Request_ArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Request_ArgsEntry_DoNotUse*>(&_Request_ArgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Request.ArgsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_microservice_2eproto;
};

// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 6,
    kFilesFieldNumber = 25,
    kModuleFieldNumber = 1,
    kParamFieldNumber = 2,
    kParamIDFieldNumber = 3,
    kParamIDDFieldNumber = 4,
    kActionFieldNumber = 5,
    kPathFieldNumber = 7,
    kTokenFieldNumber = 8,
    kSignFieldNumber = 9,
    kSIDFieldNumber = 10,
    kIPFieldNumber = 11,
    kUserAgentFieldNumber = 12,
    kTokenTypeFieldNumber = 13,
    kLanguageFieldNumber = 15,
    kAPIVersionFieldNumber = 16,
    kMethodFieldNumber = 17,
    kUIDFieldNumber = 18,
    kFileFieldNumber = 23,
    kFilenameFieldNumber = 24,
    kIRFieldNumber = 26,
    kTimeStampFieldNumber = 14,
    kIsAdminFieldNumber = 19,
    kSessionEndFieldNumber = 20,
    kCompletedFieldNumber = 21,
    kReadonlyFieldNumber = 22,
  };
  // map<string, .google.protobuf.Any> Args = 6;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_args();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_args();

  // repeated string Files = 25;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  const std::string& files(int index) const;
  std::string* mutable_files(int index);
  void set_files(int index, const std::string& value);
  void set_files(int index, std::string&& value);
  void set_files(int index, const char* value);
  void set_files(int index, const char* value, size_t size);
  std::string* add_files();
  void add_files(const std::string& value);
  void add_files(std::string&& value);
  void add_files(const char* value);
  void add_files(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_files();
  private:
  const std::string& _internal_files(int index) const;
  std::string* _internal_add_files();
  public:

  // optional string Module = 1;
  bool has_module() const;
  private:
  bool _internal_has_module() const;
  public:
  void clear_module();
  const std::string& module() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module();
  PROTOBUF_NODISCARD std::string* release_module();
  void set_allocated_module(std::string* module);
  private:
  const std::string& _internal_module() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module(const std::string& value);
  std::string* _internal_mutable_module();
  public:

  // optional string Param = 2;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const std::string& param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_param();
  PROTOBUF_NODISCARD std::string* release_param();
  void set_allocated_param(std::string* param);
  private:
  const std::string& _internal_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param(const std::string& value);
  std::string* _internal_mutable_param();
  public:

  // optional string ParamID = 3;
  bool has_paramid() const;
  private:
  bool _internal_has_paramid() const;
  public:
  void clear_paramid();
  const std::string& paramid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_paramid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_paramid();
  PROTOBUF_NODISCARD std::string* release_paramid();
  void set_allocated_paramid(std::string* paramid);
  private:
  const std::string& _internal_paramid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_paramid(const std::string& value);
  std::string* _internal_mutable_paramid();
  public:

  // optional string ParamIDD = 4;
  bool has_paramidd() const;
  private:
  bool _internal_has_paramidd() const;
  public:
  void clear_paramidd();
  const std::string& paramidd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_paramidd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_paramidd();
  PROTOBUF_NODISCARD std::string* release_paramidd();
  void set_allocated_paramidd(std::string* paramidd);
  private:
  const std::string& _internal_paramidd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_paramidd(const std::string& value);
  std::string* _internal_mutable_paramidd();
  public:

  // optional string Action = 5;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // optional string Path = 7;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // optional string Token = 8;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional string Sign = 9;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const std::string& sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign();
  PROTOBUF_NODISCARD std::string* release_sign();
  void set_allocated_sign(std::string* sign);
  private:
  const std::string& _internal_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign(const std::string& value);
  std::string* _internal_mutable_sign();
  public:

  // optional string SID = 10;
  bool has_sid() const;
  private:
  bool _internal_has_sid() const;
  public:
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // optional string IP = 11;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // optional string UserAgent = 12;
  bool has_useragent() const;
  private:
  bool _internal_has_useragent() const;
  public:
  void clear_useragent();
  const std::string& useragent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_useragent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_useragent();
  PROTOBUF_NODISCARD std::string* release_useragent();
  void set_allocated_useragent(std::string* useragent);
  private:
  const std::string& _internal_useragent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_useragent(const std::string& value);
  std::string* _internal_mutable_useragent();
  public:

  // optional string TokenType = 13;
  bool has_tokentype() const;
  private:
  bool _internal_has_tokentype() const;
  public:
  void clear_tokentype();
  const std::string& tokentype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tokentype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tokentype();
  PROTOBUF_NODISCARD std::string* release_tokentype();
  void set_allocated_tokentype(std::string* tokentype);
  private:
  const std::string& _internal_tokentype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokentype(const std::string& value);
  std::string* _internal_mutable_tokentype();
  public:

  // optional string Language = 15;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string APIVersion = 16;
  bool has_apiversion() const;
  private:
  bool _internal_has_apiversion() const;
  public:
  void clear_apiversion();
  const std::string& apiversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_apiversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_apiversion();
  PROTOBUF_NODISCARD std::string* release_apiversion();
  void set_allocated_apiversion(std::string* apiversion);
  private:
  const std::string& _internal_apiversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_apiversion(const std::string& value);
  std::string* _internal_mutable_apiversion();
  public:

  // optional string Method = 17;
  bool has_method() const;
  private:
  bool _internal_has_method() const;
  public:
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // optional string UID = 18;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // optional bytes File = 23;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const std::string& file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file();
  PROTOBUF_NODISCARD std::string* release_file();
  void set_allocated_file(std::string* file);
  private:
  const std::string& _internal_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file(const std::string& value);
  std::string* _internal_mutable_file();
  public:

  // optional string Filename = 24;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional .InternalRequest IR = 26;
  bool has_ir() const;
  private:
  bool _internal_has_ir() const;
  public:
  void clear_ir();
  const ::InternalRequest& ir() const;
  PROTOBUF_NODISCARD ::InternalRequest* release_ir();
  ::InternalRequest* mutable_ir();
  void set_allocated_ir(::InternalRequest* ir);
  private:
  const ::InternalRequest& _internal_ir() const;
  ::InternalRequest* _internal_mutable_ir();
  public:
  void unsafe_arena_set_allocated_ir(
      ::InternalRequest* ir);
  ::InternalRequest* unsafe_arena_release_ir();

  // optional int32 TimeStamp = 14;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int32_t timestamp() const;
  void set_timestamp(int32_t value);
  private:
  int32_t _internal_timestamp() const;
  void _internal_set_timestamp(int32_t value);
  public:

  // optional int32 IsAdmin = 19;
  bool has_isadmin() const;
  private:
  bool _internal_has_isadmin() const;
  public:
  void clear_isadmin();
  int32_t isadmin() const;
  void set_isadmin(int32_t value);
  private:
  int32_t _internal_isadmin() const;
  void _internal_set_isadmin(int32_t value);
  public:

  // optional int32 SessionEnd = 20;
  bool has_sessionend() const;
  private:
  bool _internal_has_sessionend() const;
  public:
  void clear_sessionend();
  int32_t sessionend() const;
  void set_sessionend(int32_t value);
  private:
  int32_t _internal_sessionend() const;
  void _internal_set_sessionend(int32_t value);
  public:

  // optional int32 Completed = 21;
  bool has_completed() const;
  private:
  bool _internal_has_completed() const;
  public:
  void clear_completed();
  int32_t completed() const;
  void set_completed(int32_t value);
  private:
  int32_t _internal_completed() const;
  void _internal_set_completed(int32_t value);
  public:

  // optional int32 Readonly = 22;
  bool has_readonly() const;
  private:
  bool _internal_has_readonly() const;
  public:
  void clear_readonly();
  int32_t readonly() const;
  void set_readonly(int32_t value);
  private:
  int32_t _internal_readonly() const;
  void _internal_set_readonly(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Request_ArgsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> args_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> files_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr param_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr paramid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr paramidd_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr useragent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokentype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr apiversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::InternalRequest* ir_;
    int32_t timestamp_;
    int32_t isadmin_;
    int32_t sessionend_;
    int32_t completed_;
    int32_t readonly_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_microservice_2eproto;
};
// -------------------------------------------------------------------

class InternalRequest_ArgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InternalRequest_ArgsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InternalRequest_ArgsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  InternalRequest_ArgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR InternalRequest_ArgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InternalRequest_ArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InternalRequest_ArgsEntry_DoNotUse& other);
  static const InternalRequest_ArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InternalRequest_ArgsEntry_DoNotUse*>(&_InternalRequest_ArgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "InternalRequest.ArgsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_microservice_2eproto;
};

// -------------------------------------------------------------------

class InternalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InternalRequest) */ {
 public:
  inline InternalRequest() : InternalRequest(nullptr) {}
  ~InternalRequest() override;
  explicit PROTOBUF_CONSTEXPR InternalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternalRequest(const InternalRequest& from);
  InternalRequest(InternalRequest&& from) noexcept
    : InternalRequest() {
    *this = ::std::move(from);
  }

  inline InternalRequest& operator=(const InternalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalRequest& operator=(InternalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternalRequest* internal_default_instance() {
    return reinterpret_cast<const InternalRequest*>(
               &_InternalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InternalRequest& a, InternalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InternalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InternalRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InternalRequest& from) {
    InternalRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InternalRequest";
  }
  protected:
  explicit InternalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 4,
    kParamFieldNumber = 1,
    kParamIDFieldNumber = 2,
    kMethodFieldNumber = 3,
  };
  // map<string, .google.protobuf.Any> Args = 4;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_args();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_args();

  // optional string Param = 1;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const std::string& param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_param();
  PROTOBUF_NODISCARD std::string* release_param();
  void set_allocated_param(std::string* param);
  private:
  const std::string& _internal_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param(const std::string& value);
  std::string* _internal_mutable_param();
  public:

  // optional string ParamID = 2;
  bool has_paramid() const;
  private:
  bool _internal_has_paramid() const;
  public:
  void clear_paramid();
  const std::string& paramid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_paramid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_paramid();
  PROTOBUF_NODISCARD std::string* release_paramid();
  void set_allocated_paramid(std::string* paramid);
  private:
  const std::string& _internal_paramid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_paramid(const std::string& value);
  std::string* _internal_mutable_paramid();
  public:

  // optional string Method = 3;
  bool has_method() const;
  private:
  bool _internal_has_method() const;
  public:
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // @@protoc_insertion_point(class_scope:InternalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        InternalRequest_ArgsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr param_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr paramid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_microservice_2eproto;
};
// -------------------------------------------------------------------

class Error_MetaEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Error_MetaEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Error_MetaEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Error_MetaEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Error_MetaEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Error_MetaEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Error_MetaEntry_DoNotUse& other);
  static const Error_MetaEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Error_MetaEntry_DoNotUse*>(&_Error_MetaEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Error.MetaEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Error.MetaEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_microservice_2eproto;
};

// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit PROTOBUF_CONSTEXPR Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Error& from) {
    Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 3,
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // map<string, string> meta = 3;
  int meta_size() const;
  private:
  int _internal_meta_size() const;
  public:
  void clear_meta();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_meta() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_meta();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      meta() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_meta();

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Error_MetaEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> meta_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_microservice_2eproto;
};
// -------------------------------------------------------------------

class Response_DataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_DataEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_DataEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Response_DataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Response_DataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Response_DataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Response_DataEntry_DoNotUse& other);
  static const Response_DataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Response_DataEntry_DoNotUse*>(&_Response_DataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Response.DataEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_microservice_2eproto;
};

// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kRequestBackFieldNumber = 2,
    kErrorFieldNumber = 4,
    kCodeFieldNumber = 3,
  };
  // map<string, .google.protobuf.Any> Data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_data();

  // optional .Request RequestBack = 2;
  bool has_requestback() const;
  private:
  bool _internal_has_requestback() const;
  public:
  void clear_requestback();
  const ::Request& requestback() const;
  PROTOBUF_NODISCARD ::Request* release_requestback();
  ::Request* mutable_requestback();
  void set_allocated_requestback(::Request* requestback);
  private:
  const ::Request& _internal_requestback() const;
  ::Request* _internal_mutable_requestback();
  public:
  void unsafe_arena_set_allocated_requestback(
      ::Request* requestback);
  ::Request* unsafe_arena_release_requestback();

  // optional .Error error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::Error& error() const;
  PROTOBUF_NODISCARD ::Error* release_error();
  ::Error* mutable_error();
  void set_allocated_error(::Error* error);
  private:
  const ::Error& _internal_error() const;
  ::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::Error* error);
  ::Error* unsafe_arena_release_error();

  // optional .UploadStatusCode Code = 3;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  ::UploadStatusCode code() const;
  void set_code(::UploadStatusCode value);
  private:
  ::UploadStatusCode _internal_code() const;
  void _internal_set_code(::UploadStatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Response_DataEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> data_;
    ::Request* requestback_;
    ::Error* error_;
    int code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_microservice_2eproto;
};
// -------------------------------------------------------------------

class FileChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileChunk) */ {
 public:
  inline FileChunk() : FileChunk(nullptr) {}
  ~FileChunk() override;
  explicit PROTOBUF_CONSTEXPR FileChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileChunk(const FileChunk& from);
  FileChunk(FileChunk&& from) noexcept
    : FileChunk() {
    *this = ::std::move(from);
  }

  inline FileChunk& operator=(const FileChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileChunk& operator=(FileChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileChunk* internal_default_instance() {
    return reinterpret_cast<const FileChunk*>(
               &_FileChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FileChunk& a, FileChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(FileChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileChunk& from) {
    FileChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileChunk";
  }
  protected:
  explicit FileChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:FileChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_microservice_2eproto;
};
// -------------------------------------------------------------------

class StringMap_EntriesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StringMap_EntriesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StringMap_EntriesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  StringMap_EntriesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR StringMap_EntriesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit StringMap_EntriesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StringMap_EntriesEntry_DoNotUse& other);
  static const StringMap_EntriesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StringMap_EntriesEntry_DoNotUse*>(&_StringMap_EntriesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "StringMap.EntriesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "StringMap.EntriesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_microservice_2eproto;
};

// -------------------------------------------------------------------

class StringMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StringMap) */ {
 public:
  inline StringMap() : StringMap(nullptr) {}
  ~StringMap() override;
  explicit PROTOBUF_CONSTEXPR StringMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringMap(const StringMap& from);
  StringMap(StringMap&& from) noexcept
    : StringMap() {
    *this = ::std::move(from);
  }

  inline StringMap& operator=(const StringMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringMap& operator=(StringMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringMap* internal_default_instance() {
    return reinterpret_cast<const StringMap*>(
               &_StringMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StringMap& a, StringMap& b) {
    a.Swap(&b);
  }
  inline void Swap(StringMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringMap& from) {
    StringMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StringMap";
  }
  protected:
  explicit StringMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // map<string, string> entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_entries() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_entries();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      entries() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:StringMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        StringMap_EntriesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_microservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Request

// optional string Module = 1;
inline bool Request::_internal_has_module() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Request::has_module() const {
  return _internal_has_module();
}
inline void Request::clear_module() {
  _impl_.module_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Request::module() const {
  // @@protoc_insertion_point(field_get:Request.Module)
  return _internal_module();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_module(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.module_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.Module)
}
inline std::string* Request::mutable_module() {
  std::string* _s = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:Request.Module)
  return _s;
}
inline const std::string& Request::_internal_module() const {
  return _impl_.module_.Get();
}
inline void Request::_internal_set_module(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.module_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_module() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.module_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_module() {
  // @@protoc_insertion_point(field_release:Request.Module)
  if (!_internal_has_module()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.module_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_.IsDefault()) {
    _impl_.module_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_module(std::string* module) {
  if (module != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.module_.SetAllocated(module, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_.IsDefault()) {
    _impl_.module_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.Module)
}

// optional string Param = 2;
inline bool Request::_internal_has_param() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Request::has_param() const {
  return _internal_has_param();
}
inline void Request::clear_param() {
  _impl_.param_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Request::param() const {
  // @@protoc_insertion_point(field_get:Request.Param)
  return _internal_param();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_param(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.param_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.Param)
}
inline std::string* Request::mutable_param() {
  std::string* _s = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:Request.Param)
  return _s;
}
inline const std::string& Request::_internal_param() const {
  return _impl_.param_.Get();
}
inline void Request::_internal_set_param(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.param_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_param() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.param_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_param() {
  // @@protoc_insertion_point(field_release:Request.Param)
  if (!_internal_has_param()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.param_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.param_.IsDefault()) {
    _impl_.param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_param(std::string* param) {
  if (param != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.param_.SetAllocated(param, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.param_.IsDefault()) {
    _impl_.param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.Param)
}

// optional string ParamID = 3;
inline bool Request::_internal_has_paramid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Request::has_paramid() const {
  return _internal_has_paramid();
}
inline void Request::clear_paramid() {
  _impl_.paramid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Request::paramid() const {
  // @@protoc_insertion_point(field_get:Request.ParamID)
  return _internal_paramid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_paramid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.paramid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.ParamID)
}
inline std::string* Request::mutable_paramid() {
  std::string* _s = _internal_mutable_paramid();
  // @@protoc_insertion_point(field_mutable:Request.ParamID)
  return _s;
}
inline const std::string& Request::_internal_paramid() const {
  return _impl_.paramid_.Get();
}
inline void Request::_internal_set_paramid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.paramid_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_paramid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.paramid_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_paramid() {
  // @@protoc_insertion_point(field_release:Request.ParamID)
  if (!_internal_has_paramid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.paramid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paramid_.IsDefault()) {
    _impl_.paramid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_paramid(std::string* paramid) {
  if (paramid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.paramid_.SetAllocated(paramid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paramid_.IsDefault()) {
    _impl_.paramid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.ParamID)
}

// optional string ParamIDD = 4;
inline bool Request::_internal_has_paramidd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Request::has_paramidd() const {
  return _internal_has_paramidd();
}
inline void Request::clear_paramidd() {
  _impl_.paramidd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Request::paramidd() const {
  // @@protoc_insertion_point(field_get:Request.ParamIDD)
  return _internal_paramidd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_paramidd(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.paramidd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.ParamIDD)
}
inline std::string* Request::mutable_paramidd() {
  std::string* _s = _internal_mutable_paramidd();
  // @@protoc_insertion_point(field_mutable:Request.ParamIDD)
  return _s;
}
inline const std::string& Request::_internal_paramidd() const {
  return _impl_.paramidd_.Get();
}
inline void Request::_internal_set_paramidd(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.paramidd_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_paramidd() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.paramidd_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_paramidd() {
  // @@protoc_insertion_point(field_release:Request.ParamIDD)
  if (!_internal_has_paramidd()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.paramidd_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paramidd_.IsDefault()) {
    _impl_.paramidd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_paramidd(std::string* paramidd) {
  if (paramidd != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.paramidd_.SetAllocated(paramidd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paramidd_.IsDefault()) {
    _impl_.paramidd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.ParamIDD)
}

// optional string Action = 5;
inline bool Request::_internal_has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Request::has_action() const {
  return _internal_has_action();
}
inline void Request::clear_action() {
  _impl_.action_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Request::action() const {
  // @@protoc_insertion_point(field_get:Request.Action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_action(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.Action)
}
inline std::string* Request::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:Request.Action)
  return _s;
}
inline const std::string& Request::_internal_action() const {
  return _impl_.action_.Get();
}
inline void Request::_internal_set_action(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_action() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.action_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_action() {
  // @@protoc_insertion_point(field_release:Request.Action)
  if (!_internal_has_action()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.action_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.action_.SetAllocated(action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.Action)
}

// map<string, .google.protobuf.Any> Args = 6;
inline int Request::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int Request::args_size() const {
  return _internal_args_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Request::_internal_args() const {
  return _impl_.args_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Request::args() const {
  // @@protoc_insertion_point(field_map:Request.Args)
  return _internal_args();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Request::_internal_mutable_args() {
  return _impl_.args_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Request::mutable_args() {
  // @@protoc_insertion_point(field_mutable_map:Request.Args)
  return _internal_mutable_args();
}

// optional string Path = 7;
inline bool Request::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Request::has_path() const {
  return _internal_has_path();
}
inline void Request::clear_path() {
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Request::path() const {
  // @@protoc_insertion_point(field_get:Request.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.Path)
}
inline std::string* Request::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:Request.Path)
  return _s;
}
inline const std::string& Request::_internal_path() const {
  return _impl_.path_.Get();
}
inline void Request::_internal_set_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_path() {
  // @@protoc_insertion_point(field_release:Request.Path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.Path)
}

// optional string Token = 8;
inline bool Request::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Request::has_token() const {
  return _internal_has_token();
}
inline void Request::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& Request::token() const {
  // @@protoc_insertion_point(field_get:Request.Token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.Token)
}
inline std::string* Request::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:Request.Token)
  return _s;
}
inline const std::string& Request::_internal_token() const {
  return _impl_.token_.Get();
}
inline void Request::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_token() {
  // @@protoc_insertion_point(field_release:Request.Token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.Token)
}

// optional string Sign = 9;
inline bool Request::_internal_has_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Request::has_sign() const {
  return _internal_has_sign();
}
inline void Request::clear_sign() {
  _impl_.sign_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& Request::sign() const {
  // @@protoc_insertion_point(field_get:Request.Sign)
  return _internal_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_sign(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.sign_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.Sign)
}
inline std::string* Request::mutable_sign() {
  std::string* _s = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:Request.Sign)
  return _s;
}
inline const std::string& Request::_internal_sign() const {
  return _impl_.sign_.Get();
}
inline void Request::_internal_set_sign(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.sign_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_sign() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.sign_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_sign() {
  // @@protoc_insertion_point(field_release:Request.Sign)
  if (!_internal_has_sign()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.sign_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sign_.IsDefault()) {
    _impl_.sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_sign(std::string* sign) {
  if (sign != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.sign_.SetAllocated(sign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sign_.IsDefault()) {
    _impl_.sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.Sign)
}

// optional string SID = 10;
inline bool Request::_internal_has_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Request::has_sid() const {
  return _internal_has_sid();
}
inline void Request::clear_sid() {
  _impl_.sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& Request::sid() const {
  // @@protoc_insertion_point(field_get:Request.SID)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.SID)
}
inline std::string* Request::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:Request.SID)
  return _s;
}
inline const std::string& Request::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void Request::_internal_set_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_sid() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_sid() {
  // @@protoc_insertion_point(field_release:Request.SID)
  if (!_internal_has_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.SID)
}

// optional string IP = 11;
inline bool Request::_internal_has_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Request::has_ip() const {
  return _internal_has_ip();
}
inline void Request::clear_ip() {
  _impl_.ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& Request::ip() const {
  // @@protoc_insertion_point(field_get:Request.IP)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_ip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.IP)
}
inline std::string* Request::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:Request.IP)
  return _s;
}
inline const std::string& Request::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void Request::_internal_set_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_ip() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_ip() {
  // @@protoc_insertion_point(field_release:Request.IP)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.IP)
}

// optional string UserAgent = 12;
inline bool Request::_internal_has_useragent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Request::has_useragent() const {
  return _internal_has_useragent();
}
inline void Request::clear_useragent() {
  _impl_.useragent_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& Request::useragent() const {
  // @@protoc_insertion_point(field_get:Request.UserAgent)
  return _internal_useragent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_useragent(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.useragent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.UserAgent)
}
inline std::string* Request::mutable_useragent() {
  std::string* _s = _internal_mutable_useragent();
  // @@protoc_insertion_point(field_mutable:Request.UserAgent)
  return _s;
}
inline const std::string& Request::_internal_useragent() const {
  return _impl_.useragent_.Get();
}
inline void Request::_internal_set_useragent(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.useragent_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_useragent() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.useragent_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_useragent() {
  // @@protoc_insertion_point(field_release:Request.UserAgent)
  if (!_internal_has_useragent()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.useragent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.useragent_.IsDefault()) {
    _impl_.useragent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_useragent(std::string* useragent) {
  if (useragent != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.useragent_.SetAllocated(useragent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.useragent_.IsDefault()) {
    _impl_.useragent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.UserAgent)
}

// optional string TokenType = 13;
inline bool Request::_internal_has_tokentype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Request::has_tokentype() const {
  return _internal_has_tokentype();
}
inline void Request::clear_tokentype() {
  _impl_.tokentype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& Request::tokentype() const {
  // @@protoc_insertion_point(field_get:Request.TokenType)
  return _internal_tokentype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_tokentype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.tokentype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.TokenType)
}
inline std::string* Request::mutable_tokentype() {
  std::string* _s = _internal_mutable_tokentype();
  // @@protoc_insertion_point(field_mutable:Request.TokenType)
  return _s;
}
inline const std::string& Request::_internal_tokentype() const {
  return _impl_.tokentype_.Get();
}
inline void Request::_internal_set_tokentype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.tokentype_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_tokentype() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.tokentype_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_tokentype() {
  // @@protoc_insertion_point(field_release:Request.TokenType)
  if (!_internal_has_tokentype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.tokentype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tokentype_.IsDefault()) {
    _impl_.tokentype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_tokentype(std::string* tokentype) {
  if (tokentype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.tokentype_.SetAllocated(tokentype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tokentype_.IsDefault()) {
    _impl_.tokentype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.TokenType)
}

// optional int32 TimeStamp = 14;
inline bool Request::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Request::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Request::clear_timestamp() {
  _impl_.timestamp_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline int32_t Request::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int32_t Request::timestamp() const {
  // @@protoc_insertion_point(field_get:Request.TimeStamp)
  return _internal_timestamp();
}
inline void Request::_internal_set_timestamp(int32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.timestamp_ = value;
}
inline void Request::set_timestamp(int32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:Request.TimeStamp)
}

// optional string Language = 15;
inline bool Request::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Request::has_language() const {
  return _internal_has_language();
}
inline void Request::clear_language() {
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& Request::language() const {
  // @@protoc_insertion_point(field_get:Request.Language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00001000u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.Language)
}
inline std::string* Request::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:Request.Language)
  return _s;
}
inline const std::string& Request::_internal_language() const {
  return _impl_.language_.Get();
}
inline void Request::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_language() {
  // @@protoc_insertion_point(field_release:Request.Language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* p = _impl_.language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.Language)
}

// optional string APIVersion = 16;
inline bool Request::_internal_has_apiversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Request::has_apiversion() const {
  return _internal_has_apiversion();
}
inline void Request::clear_apiversion() {
  _impl_.apiversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& Request::apiversion() const {
  // @@protoc_insertion_point(field_get:Request.APIVersion)
  return _internal_apiversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_apiversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00002000u;
 _impl_.apiversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.APIVersion)
}
inline std::string* Request::mutable_apiversion() {
  std::string* _s = _internal_mutable_apiversion();
  // @@protoc_insertion_point(field_mutable:Request.APIVersion)
  return _s;
}
inline const std::string& Request::_internal_apiversion() const {
  return _impl_.apiversion_.Get();
}
inline void Request::_internal_set_apiversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.apiversion_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_apiversion() {
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.apiversion_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_apiversion() {
  // @@protoc_insertion_point(field_release:Request.APIVersion)
  if (!_internal_has_apiversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* p = _impl_.apiversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.apiversion_.IsDefault()) {
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_apiversion(std::string* apiversion) {
  if (apiversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.apiversion_.SetAllocated(apiversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.apiversion_.IsDefault()) {
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.APIVersion)
}

// optional string Method = 17;
inline bool Request::_internal_has_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Request::has_method() const {
  return _internal_has_method();
}
inline void Request::clear_method() {
  _impl_.method_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& Request::method() const {
  // @@protoc_insertion_point(field_get:Request.Method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_method(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00004000u;
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.Method)
}
inline std::string* Request::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:Request.Method)
  return _s;
}
inline const std::string& Request::_internal_method() const {
  return _impl_.method_.Get();
}
inline void Request::_internal_set_method(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_method() {
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_method() {
  // @@protoc_insertion_point(field_release:Request.Method)
  if (!_internal_has_method()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* p = _impl_.method_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.Method)
}

// optional string UID = 18;
inline bool Request::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Request::has_uid() const {
  return _internal_has_uid();
}
inline void Request::clear_uid() {
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const std::string& Request::uid() const {
  // @@protoc_insertion_point(field_get:Request.UID)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_uid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00008000u;
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.UID)
}
inline std::string* Request::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:Request.UID)
  return _s;
}
inline const std::string& Request::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void Request::_internal_set_uid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_uid() {
  _impl_._has_bits_[0] |= 0x00008000u;
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_uid() {
  // @@protoc_insertion_point(field_release:Request.UID)
  if (!_internal_has_uid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00008000u;
  auto* p = _impl_.uid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.UID)
}

// optional int32 IsAdmin = 19;
inline bool Request::_internal_has_isadmin() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Request::has_isadmin() const {
  return _internal_has_isadmin();
}
inline void Request::clear_isadmin() {
  _impl_.isadmin_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline int32_t Request::_internal_isadmin() const {
  return _impl_.isadmin_;
}
inline int32_t Request::isadmin() const {
  // @@protoc_insertion_point(field_get:Request.IsAdmin)
  return _internal_isadmin();
}
inline void Request::_internal_set_isadmin(int32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.isadmin_ = value;
}
inline void Request::set_isadmin(int32_t value) {
  _internal_set_isadmin(value);
  // @@protoc_insertion_point(field_set:Request.IsAdmin)
}

// optional int32 SessionEnd = 20;
inline bool Request::_internal_has_sessionend() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Request::has_sessionend() const {
  return _internal_has_sessionend();
}
inline void Request::clear_sessionend() {
  _impl_.sessionend_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline int32_t Request::_internal_sessionend() const {
  return _impl_.sessionend_;
}
inline int32_t Request::sessionend() const {
  // @@protoc_insertion_point(field_get:Request.SessionEnd)
  return _internal_sessionend();
}
inline void Request::_internal_set_sessionend(int32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.sessionend_ = value;
}
inline void Request::set_sessionend(int32_t value) {
  _internal_set_sessionend(value);
  // @@protoc_insertion_point(field_set:Request.SessionEnd)
}

// optional int32 Completed = 21;
inline bool Request::_internal_has_completed() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Request::has_completed() const {
  return _internal_has_completed();
}
inline void Request::clear_completed() {
  _impl_.completed_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline int32_t Request::_internal_completed() const {
  return _impl_.completed_;
}
inline int32_t Request::completed() const {
  // @@protoc_insertion_point(field_get:Request.Completed)
  return _internal_completed();
}
inline void Request::_internal_set_completed(int32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.completed_ = value;
}
inline void Request::set_completed(int32_t value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:Request.Completed)
}

// optional int32 Readonly = 22;
inline bool Request::_internal_has_readonly() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Request::has_readonly() const {
  return _internal_has_readonly();
}
inline void Request::clear_readonly() {
  _impl_.readonly_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline int32_t Request::_internal_readonly() const {
  return _impl_.readonly_;
}
inline int32_t Request::readonly() const {
  // @@protoc_insertion_point(field_get:Request.Readonly)
  return _internal_readonly();
}
inline void Request::_internal_set_readonly(int32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.readonly_ = value;
}
inline void Request::set_readonly(int32_t value) {
  _internal_set_readonly(value);
  // @@protoc_insertion_point(field_set:Request.Readonly)
}

// optional bytes File = 23;
inline bool Request::_internal_has_file() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Request::has_file() const {
  return _internal_has_file();
}
inline void Request::clear_file() {
  _impl_.file_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const std::string& Request::file() const {
  // @@protoc_insertion_point(field_get:Request.File)
  return _internal_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_file(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00010000u;
 _impl_.file_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.File)
}
inline std::string* Request::mutable_file() {
  std::string* _s = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:Request.File)
  return _s;
}
inline const std::string& Request::_internal_file() const {
  return _impl_.file_.Get();
}
inline void Request::_internal_set_file(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.file_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_file() {
  _impl_._has_bits_[0] |= 0x00010000u;
  return _impl_.file_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_file() {
  // @@protoc_insertion_point(field_release:Request.File)
  if (!_internal_has_file()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00010000u;
  auto* p = _impl_.file_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_.IsDefault()) {
    _impl_.file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_file(std::string* file) {
  if (file != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.file_.SetAllocated(file, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_.IsDefault()) {
    _impl_.file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.File)
}

// optional string Filename = 24;
inline bool Request::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Request::has_filename() const {
  return _internal_has_filename();
}
inline void Request::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const std::string& Request::filename() const {
  // @@protoc_insertion_point(field_get:Request.Filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00020000u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Request.Filename)
}
inline std::string* Request::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:Request.Filename)
  return _s;
}
inline const std::string& Request::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void Request::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00020000u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_filename() {
  // @@protoc_insertion_point(field_release:Request.Filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00020000u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Request::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Request.Filename)
}

// repeated string Files = 25;
inline int Request::_internal_files_size() const {
  return _impl_.files_.size();
}
inline int Request::files_size() const {
  return _internal_files_size();
}
inline void Request::clear_files() {
  _impl_.files_.Clear();
}
inline std::string* Request::add_files() {
  std::string* _s = _internal_add_files();
  // @@protoc_insertion_point(field_add_mutable:Request.Files)
  return _s;
}
inline const std::string& Request::_internal_files(int index) const {
  return _impl_.files_.Get(index);
}
inline const std::string& Request::files(int index) const {
  // @@protoc_insertion_point(field_get:Request.Files)
  return _internal_files(index);
}
inline std::string* Request::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:Request.Files)
  return _impl_.files_.Mutable(index);
}
inline void Request::set_files(int index, const std::string& value) {
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Request.Files)
}
inline void Request::set_files(int index, std::string&& value) {
  _impl_.files_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Request.Files)
}
inline void Request::set_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Request.Files)
}
inline void Request::set_files(int index, const char* value, size_t size) {
  _impl_.files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Request.Files)
}
inline std::string* Request::_internal_add_files() {
  return _impl_.files_.Add();
}
inline void Request::add_files(const std::string& value) {
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Request.Files)
}
inline void Request::add_files(std::string&& value) {
  _impl_.files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Request.Files)
}
inline void Request::add_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Request.Files)
}
inline void Request::add_files(const char* value, size_t size) {
  _impl_.files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Request.Files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Request::files() const {
  // @@protoc_insertion_point(field_list:Request.Files)
  return _impl_.files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Request::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:Request.Files)
  return &_impl_.files_;
}

// optional .InternalRequest IR = 26;
inline bool Request::_internal_has_ir() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ir_ != nullptr);
  return value;
}
inline bool Request::has_ir() const {
  return _internal_has_ir();
}
inline void Request::clear_ir() {
  if (_impl_.ir_ != nullptr) _impl_.ir_->Clear();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const ::InternalRequest& Request::_internal_ir() const {
  const ::InternalRequest* p = _impl_.ir_;
  return p != nullptr ? *p : reinterpret_cast<const ::InternalRequest&>(
      ::_InternalRequest_default_instance_);
}
inline const ::InternalRequest& Request::ir() const {
  // @@protoc_insertion_point(field_get:Request.IR)
  return _internal_ir();
}
inline void Request::unsafe_arena_set_allocated_ir(
    ::InternalRequest* ir) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ir_);
  }
  _impl_.ir_ = ir;
  if (ir) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Request.IR)
}
inline ::InternalRequest* Request::release_ir() {
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::InternalRequest* temp = _impl_.ir_;
  _impl_.ir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::InternalRequest* Request::unsafe_arena_release_ir() {
  // @@protoc_insertion_point(field_release:Request.IR)
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::InternalRequest* temp = _impl_.ir_;
  _impl_.ir_ = nullptr;
  return temp;
}
inline ::InternalRequest* Request::_internal_mutable_ir() {
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.ir_ == nullptr) {
    auto* p = CreateMaybeMessage<::InternalRequest>(GetArenaForAllocation());
    _impl_.ir_ = p;
  }
  return _impl_.ir_;
}
inline ::InternalRequest* Request::mutable_ir() {
  ::InternalRequest* _msg = _internal_mutable_ir();
  // @@protoc_insertion_point(field_mutable:Request.IR)
  return _msg;
}
inline void Request::set_allocated_ir(::InternalRequest* ir) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ir_;
  }
  if (ir) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ir);
    if (message_arena != submessage_arena) {
      ir = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ir, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.ir_ = ir;
  // @@protoc_insertion_point(field_set_allocated:Request.IR)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InternalRequest

// optional string Param = 1;
inline bool InternalRequest::_internal_has_param() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InternalRequest::has_param() const {
  return _internal_has_param();
}
inline void InternalRequest::clear_param() {
  _impl_.param_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InternalRequest::param() const {
  // @@protoc_insertion_point(field_get:InternalRequest.Param)
  return _internal_param();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalRequest::set_param(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.param_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InternalRequest.Param)
}
inline std::string* InternalRequest::mutable_param() {
  std::string* _s = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:InternalRequest.Param)
  return _s;
}
inline const std::string& InternalRequest::_internal_param() const {
  return _impl_.param_.Get();
}
inline void InternalRequest::_internal_set_param(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.param_.Set(value, GetArenaForAllocation());
}
inline std::string* InternalRequest::_internal_mutable_param() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.param_.Mutable(GetArenaForAllocation());
}
inline std::string* InternalRequest::release_param() {
  // @@protoc_insertion_point(field_release:InternalRequest.Param)
  if (!_internal_has_param()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.param_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.param_.IsDefault()) {
    _impl_.param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InternalRequest::set_allocated_param(std::string* param) {
  if (param != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.param_.SetAllocated(param, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.param_.IsDefault()) {
    _impl_.param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InternalRequest.Param)
}

// optional string ParamID = 2;
inline bool InternalRequest::_internal_has_paramid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InternalRequest::has_paramid() const {
  return _internal_has_paramid();
}
inline void InternalRequest::clear_paramid() {
  _impl_.paramid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InternalRequest::paramid() const {
  // @@protoc_insertion_point(field_get:InternalRequest.ParamID)
  return _internal_paramid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalRequest::set_paramid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.paramid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InternalRequest.ParamID)
}
inline std::string* InternalRequest::mutable_paramid() {
  std::string* _s = _internal_mutable_paramid();
  // @@protoc_insertion_point(field_mutable:InternalRequest.ParamID)
  return _s;
}
inline const std::string& InternalRequest::_internal_paramid() const {
  return _impl_.paramid_.Get();
}
inline void InternalRequest::_internal_set_paramid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.paramid_.Set(value, GetArenaForAllocation());
}
inline std::string* InternalRequest::_internal_mutable_paramid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.paramid_.Mutable(GetArenaForAllocation());
}
inline std::string* InternalRequest::release_paramid() {
  // @@protoc_insertion_point(field_release:InternalRequest.ParamID)
  if (!_internal_has_paramid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.paramid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paramid_.IsDefault()) {
    _impl_.paramid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InternalRequest::set_allocated_paramid(std::string* paramid) {
  if (paramid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.paramid_.SetAllocated(paramid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paramid_.IsDefault()) {
    _impl_.paramid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InternalRequest.ParamID)
}

// optional string Method = 3;
inline bool InternalRequest::_internal_has_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InternalRequest::has_method() const {
  return _internal_has_method();
}
inline void InternalRequest::clear_method() {
  _impl_.method_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InternalRequest::method() const {
  // @@protoc_insertion_point(field_get:InternalRequest.Method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalRequest::set_method(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InternalRequest.Method)
}
inline std::string* InternalRequest::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:InternalRequest.Method)
  return _s;
}
inline const std::string& InternalRequest::_internal_method() const {
  return _impl_.method_.Get();
}
inline void InternalRequest::_internal_set_method(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* InternalRequest::_internal_mutable_method() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* InternalRequest::release_method() {
  // @@protoc_insertion_point(field_release:InternalRequest.Method)
  if (!_internal_has_method()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.method_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InternalRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InternalRequest.Method)
}

// map<string, .google.protobuf.Any> Args = 4;
inline int InternalRequest::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int InternalRequest::args_size() const {
  return _internal_args_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
InternalRequest::_internal_args() const {
  return _impl_.args_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
InternalRequest::args() const {
  // @@protoc_insertion_point(field_map:InternalRequest.Args)
  return _internal_args();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
InternalRequest::_internal_mutable_args() {
  return _impl_.args_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
InternalRequest::mutable_args() {
  // @@protoc_insertion_point(field_mutable_map:InternalRequest.Args)
  return _internal_mutable_args();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Error

// int32 code = 1;
inline void Error::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t Error::_internal_code() const {
  return _impl_.code_;
}
inline int32_t Error::code() const {
  // @@protoc_insertion_point(field_get:Error.code)
  return _internal_code();
}
inline void Error::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void Error::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:Error.code)
}

// string message = 2;
inline void Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Error.message)
}
inline std::string* Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Error.message)
  return _s;
}
inline const std::string& Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:Error.message)
  return _impl_.message_.Release();
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Error.message)
}

// map<string, string> meta = 3;
inline int Error::_internal_meta_size() const {
  return _impl_.meta_.size();
}
inline int Error::meta_size() const {
  return _internal_meta_size();
}
inline void Error::clear_meta() {
  _impl_.meta_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Error::_internal_meta() const {
  return _impl_.meta_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Error::meta() const {
  // @@protoc_insertion_point(field_map:Error.meta)
  return _internal_meta();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Error::_internal_mutable_meta() {
  return _impl_.meta_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Error::mutable_meta() {
  // @@protoc_insertion_point(field_mutable_map:Error.meta)
  return _internal_mutable_meta();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Response

// map<string, .google.protobuf.Any> Data = 1;
inline int Response::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int Response::data_size() const {
  return _internal_data_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Response::_internal_data() const {
  return _impl_.data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Response::data() const {
  // @@protoc_insertion_point(field_map:Response.Data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Response::_internal_mutable_data() {
  return _impl_.data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Response::mutable_data() {
  // @@protoc_insertion_point(field_mutable_map:Response.Data)
  return _internal_mutable_data();
}

// optional .Request RequestBack = 2;
inline bool Response::_internal_has_requestback() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requestback_ != nullptr);
  return value;
}
inline bool Response::has_requestback() const {
  return _internal_has_requestback();
}
inline void Response::clear_requestback() {
  if (_impl_.requestback_ != nullptr) _impl_.requestback_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Request& Response::_internal_requestback() const {
  const ::Request* p = _impl_.requestback_;
  return p != nullptr ? *p : reinterpret_cast<const ::Request&>(
      ::_Request_default_instance_);
}
inline const ::Request& Response::requestback() const {
  // @@protoc_insertion_point(field_get:Response.RequestBack)
  return _internal_requestback();
}
inline void Response::unsafe_arena_set_allocated_requestback(
    ::Request* requestback) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestback_);
  }
  _impl_.requestback_ = requestback;
  if (requestback) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Response.RequestBack)
}
inline ::Request* Response::release_requestback() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Request* temp = _impl_.requestback_;
  _impl_.requestback_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Request* Response::unsafe_arena_release_requestback() {
  // @@protoc_insertion_point(field_release:Response.RequestBack)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Request* temp = _impl_.requestback_;
  _impl_.requestback_ = nullptr;
  return temp;
}
inline ::Request* Response::_internal_mutable_requestback() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.requestback_ == nullptr) {
    auto* p = CreateMaybeMessage<::Request>(GetArenaForAllocation());
    _impl_.requestback_ = p;
  }
  return _impl_.requestback_;
}
inline ::Request* Response::mutable_requestback() {
  ::Request* _msg = _internal_mutable_requestback();
  // @@protoc_insertion_point(field_mutable:Response.RequestBack)
  return _msg;
}
inline void Response::set_allocated_requestback(::Request* requestback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.requestback_;
  }
  if (requestback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(requestback);
    if (message_arena != submessage_arena) {
      requestback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requestback, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.requestback_ = requestback;
  // @@protoc_insertion_point(field_set_allocated:Response.RequestBack)
}

// optional .UploadStatusCode Code = 3;
inline bool Response::_internal_has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Response::has_code() const {
  return _internal_has_code();
}
inline void Response::clear_code() {
  _impl_.code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::UploadStatusCode Response::_internal_code() const {
  return static_cast< ::UploadStatusCode >(_impl_.code_);
}
inline ::UploadStatusCode Response::code() const {
  // @@protoc_insertion_point(field_get:Response.Code)
  return _internal_code();
}
inline void Response::_internal_set_code(::UploadStatusCode value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.code_ = value;
}
inline void Response::set_code(::UploadStatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:Response.Code)
}

// optional .Error error = 4;
inline bool Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool Response::has_error() const {
  return _internal_has_error();
}
inline void Response::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Error& Response::_internal_error() const {
  const ::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::Error&>(
      ::_Error_default_instance_);
}
inline const ::Error& Response::error() const {
  // @@protoc_insertion_point(field_get:Response.error)
  return _internal_error();
}
inline void Response::unsafe_arena_set_allocated_error(
    ::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Response.error)
}
inline ::Error* Response::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Error* Response::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:Response.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::Error* Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::Error* Response::mutable_error() {
  ::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:Response.error)
  return _msg;
}
inline void Response::set_allocated_error(::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:Response.error)
}

// -------------------------------------------------------------------

// FileChunk

// string name = 1;
inline void FileChunk::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FileChunk::name() const {
  // @@protoc_insertion_point(field_get:FileChunk.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileChunk::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileChunk.name)
}
inline std::string* FileChunk::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:FileChunk.name)
  return _s;
}
inline const std::string& FileChunk::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FileChunk::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FileChunk::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* FileChunk::release_name() {
  // @@protoc_insertion_point(field_release:FileChunk.name)
  return _impl_.name_.Release();
}
inline void FileChunk::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileChunk.name)
}

// bytes data = 2;
inline void FileChunk::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& FileChunk::data() const {
  // @@protoc_insertion_point(field_get:FileChunk.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileChunk::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileChunk.data)
}
inline std::string* FileChunk::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:FileChunk.data)
  return _s;
}
inline const std::string& FileChunk::_internal_data() const {
  return _impl_.data_.Get();
}
inline void FileChunk::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* FileChunk::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* FileChunk::release_data() {
  // @@protoc_insertion_point(field_release:FileChunk.data)
  return _impl_.data_.Release();
}
inline void FileChunk::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileChunk.data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StringMap

// map<string, string> entries = 1;
inline int StringMap::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int StringMap::entries_size() const {
  return _internal_entries_size();
}
inline void StringMap::clear_entries() {
  _impl_.entries_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StringMap::_internal_entries() const {
  return _impl_.entries_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StringMap::entries() const {
  // @@protoc_insertion_point(field_map:StringMap.entries)
  return _internal_entries();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StringMap::_internal_mutable_entries() {
  return _impl_.entries_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StringMap::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_map:StringMap.entries)
  return _internal_mutable_entries();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::UploadStatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UploadStatusCode>() {
  return ::UploadStatusCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_microservice_2eproto
